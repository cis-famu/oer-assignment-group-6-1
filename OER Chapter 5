# User-Defined Functions 

## Objectives 
When completed, students will be able to: 
1. Explain the concepts of predefined and custom-made functions.
2. Recognize functions that return values, specifying both the input parameters and the output.
3. Create and apply custom functions that return values within a program.
4. Recognize and utilize function prototypes.
5. Incorporate void functions within a program.
6. Differentiate between value and reference parameters.
7. Highlight the disparities between local and global identifiers.
8. Incorporate static variables into programming tasks.
9. Debug programs employing drivers and stubs.
10. Investigate the concept of function overloading.
11. Utilize functions with default parameters effectively.

## Introduction 

Functions serve as fundamental components, akin to building blocks, enabling the division of complex programs into manageable segments. They offer additional advantages:
1. By focusing on individual functions, programmers can concentrate solely on specific parts of the program, facilitating construction, debugging, and refinement.
2. Multiple individuals can collaborate on different functions concurrently, fostering efficient teamwork.
3. When a function is required in various sections of a program or across different programs, it can be written once and utilized repeatedly, promoting code reusability.
4. The use of functions significantly enhances program readability by reducing the intricacy of the main function.
Functions are often referred to as modules, resembling miniature programs that can be combined to form larger programs. This modular approach becomes evident when discussing 
user-defined functions. Although this aspect is less apparent with predefined functions due to their inaccessible programming code, learning about them first enables their 
effective use when necessary.

## Predefined Functions

Before exploring predefined functions in C++, let's revisit a concept from college algebra. In algebra, a function represents a rule 
or relationship between input values, known as arguments, and their corresponding output values. For instance, if f(x) = 2x + 5, 
then f(1) = 7, f(2) = 9, and  f(3) = 11, where 1, 2, and 3 are arguments, and 7, 9, and 11 are the respective output 
values of the function 'f'. 

In C++, the notion of a function, whether predefined or user-defined, mirrors that of algebraic 
functions. Each function possesses a name and performs computations based on user-supplied values. This section explores various 
predefined functions. 

Predefined mathematical functions such as `pow(x, y)`, `sqrt(x)`, and `floor(x)` are available. 

The `pow(x, y)` function calculates x^y, where x and y are parameters. For example, pow(2.0, 3) = 8.0 and pow(2.5,
3) = 15.625. As `pow(x, y)` returns values of type double, it is considered a double-type function.

The `sqrt(x)` function computes the non-negative square root of x for x >= 0.0. For instance, sqrt(2.25) = 1.5. This function also returns 
values of type double. 

The `floor(x)` function determines the largest integer less than or equal to x. For instance, floor(48.79) = 48.0. Like the previous 
functions, `floor(x)` returns values of type double. 

In C++, predefined functions are organized into separate libraries. For instance, `iostream` contains I/O functions, while `cmath` contains mathematical functions. Table 6-1 in the 
reference material lists commonly used predefined functions, along with their header file, parameter data types, and return types.
